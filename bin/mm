#!/usr/bin/env node

// Generated by CoffeeScript 1.10.0
(function() {
  var MigrationsRunner, Migrator, Promise, _, config, connect, createMigration, createMigrator, createRunner, cwd, debug, dedupe, defaults, dir, exit, fs, optparser, path, readConfig, ref, runDown, runMigrations, runSpecificDown, runSpecificUp, runUp;

  fs = require('fs');

  path = require('path');

  optparser = require('nomnom');

  _ = require('lodash');

  Promise = require('bluebird');

  connect = require('../lib/utils').connect;

  ref = require('..'), Migrator = ref.Migrator, MigrationsRunner = ref.MigrationsRunner;

  debug = !!process.env.DEBUG;

  defaults = {
    directory: "migrations"
  };

  dir = process.cwd();

  config = null;

  readConfig = function(fileName) {
    var e, error, ext, i, len, ref1;
    if (config) {
      return;
    }
    if (!fileName) {
      ref1 = ['json', 'js', 'coffee'];
      for (i = 0, len = ref1.length; i < len; i++) {
        ext = ref1[i];
        fileName = "mm-config." + ext;
        if (fs.existsSync(path.join(dir, fileName))) {
          break;
        }
        fileName = null;
      }
    }
    if (!fileName) {
      exit("Config file not specified, default not found");
    }
    try {
      fileName = path.join(dir, fileName);
      if (fileName.match(/\.coffee$/)) {
        require('coffee-script/register');
      }
      return config = _.assign({}, defaults, require(fileName));
    } catch (error) {
      e = error;
      return exit(fileName + " cannot be imported", e);
    }
  };

  cwd = function() {
    return path.join(dir, config.directory);
  };

  createMigrator = function(opts) {
    readConfig(opts.config);
    return new Migrator(config);
  };

  createRunner = function(opts) {
    readConfig(opts.config);
    return new MigrationsRunner(config);
  };

  runMigrations = function(opts) {
    return createMigrator(opts).runFromDir(cwd(), exit);
  };

  runUp = function(opts) {
    if (opts.migrations) {
      return runSpecificUp(opts);
    }
    return createRunner(opts).runUpFromDir(cwd(), exit);
  };

  runSpecificUp = function(opts) {
    var migrations;
    migrations = opts._.slice(1);
    return createRunner(opts).runSpecificUpFromDir(cwd(), migrations, exit);
  };

  runDown = function(opts) {
    if (opts.migrations) {
      return runSpecificDown(opts);
    }
    return createRunner(opts).runDownFromDir(cwd(), exit);
  };

  runSpecificDown = function(opts) {
    var migrations;
    migrations = opts._.slice(1);
    if (opts.inverse) {
      migrations = migrations.reverse();
    }
    return createRunner(opts).runSpecificDownFromDir(cwd(), migrations, exit);
  };

  createMigration = function(opts) {
    var id;
    readConfig(opts.config);
    id = opts._.slice(1).join(' ');
    if (!id) {
      exit("Migration ID is required");
    }
    return createMigrator(opts).create(cwd(), id, exit, opts.coffee);
  };

  exit = function(msg, err) {
    if (msg) {
      console.error("Error: " + msg);
      if (debug && (err != null ? err.stack : void 0)) {
        console.error(err.stack);
      }
      process.exit(1);
    }
    return process.exit(0);
  };

  dedupe = function(opts) {
    readConfig(opts.config);
    return Promise.fromCallback(function(cb) {
      return connect(config, cb);
    }).then(function(db) {
      return db.collection(config.collection);
    }).then(function(coll) {
      console.log('Loading the list of migration records...');
      return coll.find({}).toArray().then(function(docs) {
        var knownIds, mongoIdsToRemove, uniqueIds;
        console.log("Found total of " + docs.length + " records. Detecting uniques");
        knownIds = {};
        mongoIdsToRemove = [];
        uniqueIds = 0;
        docs.forEach(function(d) {
          if (knownIds[d.id]) {
            return mongoIdsToRemove.push(d._id);
          } else {
            knownIds[d.id] = true;
            return uniqueIds += 1;
          }
        });
        console.log("Found " + uniqueIds + " unique records. " + mongoIdsToRemove.length + " to remove");
        if (debug) {
          console.log(mongoIdsToRemove);
        }
        return mongoIdsToRemove;
      }).then(function(mongoIdsToRemove) {
        return coll.deleteMany({
          _id: {
            $in: mongoIdsToRemove
          }
        });
      });
    }).then(function() {
      console.log('Done');
      return exit();
    })["catch"](function(err) {
      return exit(err.message, err);
    });
  };

  optparser.script('mm').option('config', {
    metavar: 'FILE',
    help: "The name of the file in the current directory, can be .js, or .json, or .coffee.\nFor .coffee, the `coffee-script` >= 1.7.0 package must be importable from the current directory."
  });

  optparser.command('migrate').callback(runMigrations);

  optparser.nocommand().callback(runMigrations);

  optparser.command('up').option('migrations', {
    abbr: 'm',
    flag: true,
    help: "Run specific migrations. Migrations can be identified by their\nnumbers (12), IDs (my-migration), or filenames (12-my-migration.js)."
  }).callback(runUp);

  optparser.command('down').option('migrations', {
    abbr: 'm',
    flag: true,
    help: "Run specific migrations. Migrations can be identified by their\nnumbers (12), IDs (my-migration), or filenames (12-my-migration.js)."
  }).option('inverse', {
    abbr: 'i',
    flag: true,
    help: "Run migrations in reverse order.\nHandy, because `mm up --migrations X Y Z && mm down --inverse --migrations X Y Z`\nis noop (asuming the down migrations are properly implemented).\nIt's the same as `mm up --migrations X Y Z && mm down --migrations Z Y X`"
  }).callback(runDown);

  optparser.command('create').option('coffee', {
    abbr: 'c',
    flag: true,
    help: 'Generate migration stub in CoffeeScript'
  }).callback(createMigration);

  optparser.command('dedupe').help('Remove duplicate entries from the migrations collection. Fixes the regression introduced by 0.8.0 and fixed in 0.8.2.').callback(dedupe);

  optparser.parse();

}).call(this);
