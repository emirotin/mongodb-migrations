// Generated by CoffeeScript 2.5.1
(function() {
  var Migrator, Promise, _, defaultLog, fs, migrationStub, mkdirp, mongoConnect, normalizeConfig, path, repeatString;

  fs = require('fs');

  path = require('path');

  Promise = require('bluebird');

  _ = require('lodash');

  mkdirp = require('mkdirp');

  ({
    repeatString,
    connect: mongoConnect,
    normalizeConfig
  } = require('./utils'));

  migrationStub = require('./migration-stub');

  defaultLog = function(src, ...args) {
    var pad;
    pad = repeatString(' ', src === 'system' ? 4 : 2);
    return console.log(pad, ...args);
  };

  Migrator = class Migrator {
    constructor(dbConfig, logFn) {
      // this will throw in case of invalid values
      dbConfig = normalizeConfig(dbConfig);
      this._isDisposed = false;
      this._m = [];
      this._result = {};
      this._dbReady = new Promise.fromCallback(function(cb) {
        return mongoConnect(dbConfig, cb);
      }).then((client) => {
        this._client = client;
        return this._db = client.db();
      });
      this._collName = dbConfig.collection;
      this._timeout = dbConfig.timeout;
      if (logFn || logFn === null) {
        this.log = logFn;
      } else {
        this.log = defaultLog;
      }
    }

    add(m) {
      // m must be an { id, up, down } object
      return this._m.push(m);
    }

    bulkAdd(array) {
      // array must be an Array of { id, up, down } objects
      return this._m = this._m.concat(array);
    }

    _coll() {
      return this._db.collection(this._collName);
    }

    _runWhenReady(direction, cb, progress) {
      var onError, onSuccess;
      if (this._isDisposed) {
        return cb(new Error('This migrator is disposed and cannot be used anymore'));
      }
      onSuccess = () => {
        this._ranMigrations = {};
        return this._coll().find().toArray((err, docs) => {
          var doc, j, len;
          if (err) {
            return cb(err);
          }
          for (j = 0, len = docs.length; j < len; j++) {
            doc = docs[j];
            this._ranMigrations[doc.id] = true;
          }
          return this._run(direction, cb, progress);
        });
      };
      onError = function(err) {
        return cb(err);
      };
      return this._dbReady.then(onSuccess, onError);
    }

    _run(direction, done, progress) {
      var allDone, handleMigrationDone, i, l, log, logFn, m, migrationsCollection, migrationsCollectionUpdatePromises, runOne, systemLog, userLog;
      if (direction === 'down') {
        m = _(this._m).reverse().filter((m) => {
          var _r, ref;
          return (_r = (ref = this._result[m.id]) != null ? ref.status : void 0) && _r !== 'skip';
        }).value();
      } else {
        direction = 'up';
        this._result = {};
        m = this._m;
      }
      this._lastDirection = direction;
      logFn = this.log;
      log = function(src) {
        return function(msg) {
          return typeof logFn === "function" ? logFn(src, msg) : void 0;
        };
      };
      userLog = log('user');
      systemLog = log('system');
      i = 0;
      l = m.length;
      migrationsCollection = this._coll();
      migrationsCollectionUpdatePromises = [];
      handleMigrationDone = function(id) {
        var p;
        p = direction === 'up' ? Promise.fromCallback(function(cb) {
          return migrationsCollection.insertOne({id}, cb);
        }) : Promise.fromCallback(function(cb) {
          return migrationsCollection.deleteMany({id}, cb);
        });
        return migrationsCollectionUpdatePromises.push(p);
      };
      allDone = (err) => {
        Promise.all(migrationsCollectionUpdatePromises).then(() => {
          return done(err, this._result);
        });
      };
      // This return is necessary to prevent the above promise from being returned,
      // otherwise the promise will eventually be returned by the migration up/down function.
      // That would interfere with promise-based migrations, so explicitly return nothing here.
      runOne = () => {
        var context, didExecuteCallback, didReturnPromise, didTimeout, donePromise, fn, id, migration, migrationDone, promiseAndDoneError, skipCode, skipReason, timeoutId;
        if (i >= l) {
          return allDone();
        }
        migration = m[i];
        i += 1;
        migrationDone = (res) => {
          var msg, ref;
          this._result[migration.id] = res;
          _.defer(function() {
            return typeof progress === "function" ? progress(migration.id, res) : void 0;
          });
          msg = `Migration '${migration.id}': ${res.status}`;
          if (res.status === 'skip') {
            msg += ` (${res.reason})`;
          }
          systemLog(msg);
          if (res.status === 'error') {
            systemLog('  ' + res.error);
          }
          if (res.status === 'ok' || (res.status === 'skip' && ((ref = res.code) === 'no_up' || ref === 'no_down'))) {
            return handleMigrationDone(migration.id);
          }
        };
        fn = migration[direction];
        id = migration.id;
        skipReason = null;
        skipCode = null;
        if (!fn) {
          skipReason = `no migration function for direction ${direction}`;
          skipCode = `no_${direction}`;
        }
        if (direction === 'up' && id in this._ranMigrations) {
          skipReason = "migration already ran";
          skipCode = 'already_ran';
        }
        if (direction === 'down' && !(id in this._result)) {
          skipReason = "migration wasn't in the recent `migrate` run";
          skipCode = 'not_in_recent_migrate';
        }
        if (skipReason) {
          migrationDone({
            status: 'skip',
            reason: skipReason,
            code: skipCode
          });
          return runOne();
        }
        didTimeout = false;
        didReturnPromise = false;
        didExecuteCallback = false;
        promiseAndDoneError = function() {
          var err;
          err = new Error("Migration called done() AND returned a promise");
          migrationDone({
            status: 'error',
            error: err
          });
          return allDone(err);
        };
        if (this._timeout) {
          timeoutId = setTimeout(function() {
            var err;
            didTimeout = true;
            err = new Error("migration timed-out");
            migrationDone({
              status: 'error',
              error: err
            });
            return allDone(err);
          }, this._timeout);
        }
        context = {
          db: this._db,
          log: userLog,
          client: this._client
        };
        donePromise = fn.call(context, function(err) {
          didExecuteCallback = true;
          if (didTimeout) {
            return;
          }
          clearTimeout(timeoutId);
          if (didReturnPromise) {
            promiseAndDoneError();
            return;
          }
          if (err) {
            migrationDone({
              status: 'error',
              error: err
            });
            return allDone(err);
          } else {
            migrationDone({
              status: 'ok'
            });
            return runOne();
          }
        });
        if (donePromise && donePromise.then instanceof Function) {
          didReturnPromise = true;
          if (didExecuteCallback) {
            promiseAndDoneError();
            return;
          }
          return donePromise.then(function() {
            if (didTimeout) {
              return;
            }
            clearTimeout(timeoutId);
            migrationDone({
              status: 'ok'
            });
            return runOne();
          }).catch(function(err) {
            if (didTimeout) {
              return;
            }
            clearTimeout(timeoutId);
            migrationDone({
              status: 'error',
              error: err
            });
            return allDone(err);
          });
        }
      };
      return runOne();
    }

    migrate(done, progress) {
      this._runWhenReady('up', done, progress);
    }

    rollback(done, progress) {
      if (this._lastDirection !== 'up') {
        return done(new Error('Rollback can only be ran after migrate'));
      }
      this._runWhenReady('down', done, progress);
    }

    _loadMigrationFiles(dir, cb) {
      return mkdirp(dir, 0o0774, function(err) {
        if (err) {
          return cb(err);
        }
        return fs.readdir(dir, function(err, files) {
          if (err) {
            return cb(err);
          }
          files = files.filter(function(f) {
            var ref;
            return ((ref = path.extname(f)) === '.js' || ref === '.coffee') && !f.startsWith('.');
          }).map(function(f) {
            var n, ref;
            n = (ref = f.match(/^(\d+)/)) != null ? ref[1] : void 0;
            if (n) {
              n = parseInt(n, 10);
            } else {
              n = null;
            }
            return {
              number: n,
              name: f
            };
          }).filter(function(f) {
            return !!f.name;
          }).sort(function(f1, f2) {
            return f1.number - f2.number;
          }).map(function(f) {
            var fileName;
            fileName = path.join(dir, f.name);
            if (fileName.match(/\.coffee$/)) {
              require('coffeescript/register');
            }
            return {
              number: f.number,
              module: require(fileName)
            };
          });
          return cb(null, files);
        });
      });
    }

    runFromDir(dir, done, progress) {
      return this._loadMigrationFiles(dir, (err, files) => {
        if (err) {
          return done(err);
        }
        this.bulkAdd(_.map(files, 'module'));
        return this.migrate(done, progress);
      });
    }

    create(dir, id, done, coffeeScript = false) {
      return this._loadMigrationFiles(dir, function(err, files) {
        var body, ext, fileName, maxNum, nextNum, ref, ref1, slug;
        if (err) {
          return done(err);
        }
        maxNum = (ref = (ref1 = _.maxBy(files, 'number')) != null ? ref1.number : void 0) != null ? ref : 0;
        nextNum = maxNum + 1;
        slug = (id || '').toLowerCase().replace(/\s+/, '-');
        ext = coffeeScript ? 'coffee' : 'js';
        fileName = path.join(dir, `${nextNum}-${slug}.${ext}`);
        body = migrationStub(id, coffeeScript);
        return fs.writeFile(fileName, body, done);
      });
    }

    dispose(cb) {
      var onSuccess;
      this._isDisposed = true;
      onSuccess = () => {
        var e;
        try {
          this._client.close();
          return typeof cb === "function" ? cb(null) : void 0;
        } catch (error) {
          e = error;
          return typeof cb === "function" ? cb(e) : void 0;
        }
      };
      return this._dbReady.then(onSuccess, cb);
    }

  };

  module.exports.Migrator = Migrator;

}).call(this);
